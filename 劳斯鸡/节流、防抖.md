### 概念解释

函数节流: 频繁触发,但只在特定的时间内才执行一次代码

函数防抖: 频繁触发,但只在特定的时间内没有触发执行条件才执行一次代码

> 函数节流

函数节流应用的实际场景，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。
处理方式： 延时处理，然后如果在这段延时内又触发了事件，则重新开始延时。

	// 函数节流
	var canRun = true;
	document.getElementById("throttle").onscroll = function(){
	    if(!canRun){
	        // 判断是否已空闲，如果在执行中，则直接return
	        return;
	    }
	
	    canRun = false;
	    setTimeout(function(){
	        console.log("函数节流");
	        canRun = true;
	    }, 300);
	};
	// 函数节流的要点是，声明一个变量当标志位，记录当前代码是否在执行。
	// 如果空闲，则可以正常触发方法执行。
	// 如果代码正在执行，则取消这次方法执行，直接return。

> 函数抖动

函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。

只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。

以下还是以页面元素滚动监听的例子，来进行解析
	
	// 函数防抖
	var timer = false;
	document.getElementById("debounce").onscroll = function(){
	    clearTimeout(timer); // 清除未执行的代码，重置回初始化状态
	
	    timer = setTimeout(function(){
	        console.log("函数防抖");
	    }, 300);
	};
	// 函数防抖的要点，也是需要一个setTimeout来辅助实现。延迟执行需要跑的代码。
	// 如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。
	// 如果计时完毕，没有方法进来访问触发，则执行代码。